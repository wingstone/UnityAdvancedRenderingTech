
#pragma kernel CSMain

RWTexture2D<float4> _Result;
Texture2D<float4> _TransmittanceLut;

float4 _TransmittanceLut_Size;
float4 _SkyViewLutSize;
float4 _MultiScattering_Size;
float4 _GroundColor;
float _SolarIrradiance;

#define TRANSMITTANCE_TEXTURE_WIDTH _TransmittanceLut_Size.z
#define TRANSMITTANCE_TEXTURE_HEIGHT _TransmittanceLut_Size.w
#define SKYVIEW_TEXTURE_WIDTH _SkyViewLutSize.z
#define SKYVIEW_TEXTURE_HEIGHT _SkyViewLutSize.w

#include "UnityCG.cginc"
#include "../function.cginc"


groupshared float3 MultiScatAs1SharedMem[64];
groupshared float3 LSharedMem[64];

#define SQRTSAMPLECOUNT 8

[numthreads(1,1,64)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 pixPos = float2(id.xy) + 0.5f;
	float2 uv = pixPos / _MultiScattering_Size.zw;

	uv = float2(fromSubUvsToUnit(uv.x, _MultiScattering_Size.z), fromSubUvsToUnit(uv.y, _MultiScattering_Size.w));

    AtmosphereParameters atmosphere = (AtmosphereParameters)0;

    //---atmosphere setting

    // 所有距离以km为单位进行推导
    atmosphere.solar_irradiance = _SolarIrradiance;
    atmosphere.sun_angular_radius = 1;
    
    atmosphere.bottom_radius = 6360;
    atmosphere.bottom_radius2 = 6360 * 6360;
    atmosphere.top_radius = 6460;
    atmosphere.top_radius2 = 6460 * 6460;
    atmosphere.rayleigh_scattering = float3(5.8e-3f, 13.5e-3f, 33.1e-3f);      //Rayleigh 海平面散射系数
    atmosphere.mie_scattering = 3.996e-3f;          // Mie 海平面散射系数
    atmosphere.mie_extinction = 4.4e-3f;            // Mie 海平面消散系数
    atmosphere.mie_phase_function_g = 0.8;          // Mie phase suntion g
    atmosphere.absorption_extinction = float3(0.65e-3f, 1.881e-3f, 0.085e-3f);  // Ozone 海平面消散系数
    atmosphere.scaleHeightR = 8;
    atmosphere.scaleHeightM = 1.2;

    //---atmosphere setting end

    float cameraHight = uv.y*(atmosphere.top_radius - atmosphere.bottom_radius);
    float cosSunZenithAngle = uv.x*2 - 1;
	float3 sunDirection = float3(0.0, cosSunZenithAngle, sqrt(saturate(1.0 - cosSunZenithAngle * cosSunZenithAngle)));

	const float SphereSolidAngle = 4.0 * UNITY_PI;
	const float IsotropicPhase = 1.0 / SphereSolidAngle;
    
	const float sqrtSample = float(SQRTSAMPLECOUNT);
	float i = 0.5f + float(id.z / SQRTSAMPLECOUNT);
	float j = 0.5f + float(id.z - float((id.z / SQRTSAMPLECOUNT)*SQRTSAMPLECOUNT));
	{
		float randA = i / sqrtSample;
		float randB = j / sqrtSample;
		float theta = 2.0f * UNITY_PI * randA;
		float phi = acos(1.0f - 2.0f * randB);	// uniform distribution https://mathworld.wolfram.com/SpherePointPicking.html
		float cosPhi = cos(phi);
		float sinPhi = sin(phi);
		float cosTheta = cos(theta);
		float sinTheta = sin(theta);
        float3 eyeRay = 0;
		eyeRay.x = cosTheta * sinPhi;
		eyeRay.y = cosPhi;
		eyeRay.z = sinTheta * sinPhi;

        float3 multiScatAs1 = 0;
        float3 L = 0;

        GetSingleScattering_ForMultiScattering(atmosphere, _TransmittanceLut, cameraHight, sunDirection, eyeRay, _GroundColor, multiScatAs1, L);


		MultiScatAs1SharedMem[id.z] = multiScatAs1 * SphereSolidAngle / (sqrtSample * sqrtSample);
		LSharedMem[id.z] = L * SphereSolidAngle / (sqrtSample * sqrtSample);
	}

	GroupMemoryBarrierWithGroupSync();

	// 64 to 32
	if (id.z < 32)
	{
		MultiScatAs1SharedMem[id.z] += MultiScatAs1SharedMem[id.z + 32];
		LSharedMem[id.z] += LSharedMem[id.z + 32];
	}
	GroupMemoryBarrierWithGroupSync();

	// 32 to 16
	if (id.z < 16)
	{
		MultiScatAs1SharedMem[id.z] += MultiScatAs1SharedMem[id.z + 16];
		LSharedMem[id.z] += LSharedMem[id.z + 16];
	}
	GroupMemoryBarrierWithGroupSync();

	// 16 to 8 (16 is thread group min hardware size with intel, no sync required from there)
	if (id.z < 8)
	{
		MultiScatAs1SharedMem[id.z] += MultiScatAs1SharedMem[id.z + 8];
		LSharedMem[id.z] += LSharedMem[id.z + 8];
	}
	GroupMemoryBarrierWithGroupSync();
	if (id.z < 4)
	{
		MultiScatAs1SharedMem[id.z] += MultiScatAs1SharedMem[id.z + 4];
		LSharedMem[id.z] += LSharedMem[id.z + 4];
	}
	GroupMemoryBarrierWithGroupSync();
	if (id.z < 2)
	{
		MultiScatAs1SharedMem[id.z] += MultiScatAs1SharedMem[id.z + 2];
		LSharedMem[id.z] += LSharedMem[id.z + 2];
	}
	GroupMemoryBarrierWithGroupSync();
	if (id.z < 1)
	{
		MultiScatAs1SharedMem[id.z] += MultiScatAs1SharedMem[id.z + 1];
		LSharedMem[id.z] += LSharedMem[id.z + 1];
	}
	GroupMemoryBarrierWithGroupSync();
	if (id.z > 0)
		return;

	float3 MultiScatAs1			= MultiScatAs1SharedMem[0] * IsotropicPhase;	// Equation 7 f_ms
	float3 InScatteredLuminance	= LSharedMem[0] * IsotropicPhase;				// Equation 5 L_2ndOrder


	const float3 r = MultiScatAs1;
	const float3 SumOfAllMultiScatteringEventsContribution = 1.0f / (1.0 - r);
	float3 L = InScatteredLuminance * SumOfAllMultiScatteringEventsContribution;// Equation 10 Psi_ms

	_Result[id.xy] = float4(L, 1.0f);
}
