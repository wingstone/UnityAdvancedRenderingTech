#pragma kernel CSMainGet
#pragma kernel CSMainSet

Texture2D<float4> _CameraDepthTexture; //depth = r;
Texture2D<float4> _SourceRT;
RWTexture2D<float4> _IntermediateRT;
RWTexture2D<float4> _ResultRT;

float4 _TextureSize;
float4x4 _InverseProjectionMatrix;
float4x4 _ProjectionMatrix;
float4x4 _ViewMatrix;
float4 _CameraPos;
float _PlaneHeight;
float4 _PlaneBoxMin;
float4 _PlaneBoxMax;

SamplerState sampler_LinearClamp;
SamplerState sampler_PointClamp;

#include "UnityCG.cginc"

float3 GetWorldSpacePosition(float2 uv)
{
    float depth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, uv, 0.0).r;
    float4 result = mul(_InverseProjectionMatrix, float4(2.0 * uv - 1.0, depth, 1.0));
    return result.xyz / result.w;
}

[numthreads(8,8,1)]
void CSMainGet (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float2 uv = (id.xy+0.5)*_TextureSize.xy;
    float depth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, uv, 0.0).r;
    if(depth <= 1e-5)
        return;

    float3 pos = GetWorldSpacePosition(uv);

    // mirrorpos
    float3 mirrorPos = pos;
    mirrorPos.y = _PlaneHeight*2- mirrorPos.y;

    // intersect
    float3 camPos = _CameraPos.xyz;
    float3 intersectPos = mirrorPos + (camPos - mirrorPos)*(_PlaneHeight - mirrorPos.y)/(camPos.y - mirrorPos.y);
    if(intersectPos.x < _PlaneBoxMin.x || intersectPos.z < _PlaneBoxMin.y
    || intersectPos.x > _PlaneBoxMax.x || intersectPos.z > _PlaneBoxMax.y)
        return;

    float4 clipMirrorPos = mul(_ProjectionMatrix, float4(mirrorPos, 1));
    float2 newUV = clipMirrorPos.xy/clipMirrorPos.w*0.5 + 0.5;

    // test occlude in view space
    float occludeDepth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, newUV, 0.0).r;
    occludeDepth = -LinearEyeDepth(occludeDepth);
    float intersectDepth = mul(_ViewMatrix, float4(intersectPos, 1)).z;
    if(intersectDepth < occludeDepth)
        return;

    int2 newid = saturate(newUV)*_TextureSize.zw;
    _IntermediateRT[newid.xy] = float4(uv, 0.0, 1.0);
    
    // uint projectionHash = newUV.y << 16 | newUV.x;
    // const uint writeOffset = uint(newUV.x) + uint(newUV.y) * uint(_TextureSize.x);
    // uint originalValue = 0;
    // InterlockedMax(_IntermediateRT[writeOffset], projectionHash, originalValue);
}

////////////////////////////////////////////////////////////

[numthreads(8,8,1)]
void CSMainSet (uint3 id : SV_DispatchThreadID)
{
    float4 value = _IntermediateRT[id.xy];
    float2 newUV = value.xy;
    float alpha = value.a;
    if(alpha > 0.5)
        _ResultRT[id.xy] = float4(_SourceRT.SampleLevel(sampler_LinearClamp, newUV, 0.0).rgb, 1.0);
}
