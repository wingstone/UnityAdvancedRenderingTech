// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> _SourceRT;
Texture2D<float4> _CameraDepthTexture; //depth = r;
float4 _TextureSize;
float4x4 _InverseProjectionMatrix;
float4x4 _ProjectionMatrix;
float4x4 _ViewMatrix;
float4 _CameraPos;
float _PlaneHeight;
float4 _PlaneBoxMin;
float4 _PlaneBoxMax;

SamplerState sampler_LinearClamp;
SamplerState sampler_PointClamp;

#include "UnityCG.cginc"

float3 GetWorldSpacePosition(float2 uv)
{
    float depth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, uv, 0.0).r;
    float4 result = mul(_InverseProjectionMatrix, float4(2.0 * uv - 1.0, depth, 1.0));
    return result.xyz / result.w;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float2 uv = (id.xy+0.5)*_TextureSize.xy;
    float depth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, uv, 0.0).r;
    if(depth <= 1e-5)
        return;

    float3 pos = GetWorldSpacePosition(uv);

    // mirrorpos
    float3 mirrorPos = pos;
    mirrorPos.y = _PlaneHeight*2- mirrorPos.y;

    // intersect
    float3 camPos = _CameraPos.xyz;
    float3 intersectPos = mirrorPos + (camPos - mirrorPos)*(_PlaneHeight - mirrorPos.y)/(camPos.y - mirrorPos.y);
    if(intersectPos.x < _PlaneBoxMin.x || intersectPos.z < _PlaneBoxMin.y
    || intersectPos.x > _PlaneBoxMax.x || intersectPos.z > _PlaneBoxMax.y)
        return;

    float4 clipMirrorPos = mul(_ProjectionMatrix, float4(mirrorPos, 1));
    float2 newUV = clipMirrorPos.xy/clipMirrorPos.w*0.5 + 0.5;

    // test occlude in view space
    float occludeDepth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, newUV, 0.0).r;
    occludeDepth = -LinearEyeDepth(occludeDepth);
    float intersectDepth = mul(_ViewMatrix, float4(intersectPos, 1)).z;
    if(intersectDepth < occludeDepth)
        return;

    int2 newid = saturate(newUV)*_TextureSize.zw;
    Result[newid.xy] = float4(_SourceRT.SampleLevel(sampler_LinearClamp, uv, 0.0).rgb, 1.0);

}
